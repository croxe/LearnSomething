Kotlin in Action

Dmitry Jemerov 
Svetlana Isakova



Chapter 2-----------------------------------------------------------------------------------

fun: the keywords to declare a function.

#Parameter type, variable type is written after the parameter name
#Omit the semicolon at back

Function name: the name of the funciton, following by parameter list.
Statement: don't have its own value and always be a top-level element in its enclosing block.
Expressions: has a value and can be a part of another expression.
Block body: a function is written with its body in curly braces.
Expression body: a funciton return an expressino directly.
Type inference: complier analyze the expression's return type when there is no return type declaration.
Variable type: complier analyze the type of assigned value.

kotlin-stdlib/kotlin.collections/joinToString
fun <T> Array<out T>.joinToString(separator,prefix,postfix,lmit,trucated,transform)
connect two string

Println: In Kotlin standard library provides many wrappers around standard Java library functions, with more concise syntax.

2.1.3 Variables
Val(value): Immutable reference, A variable can't be reassigned after initialized.
Var(variable): Mutable reference, A variable can be reassigned afte initialized.

Val reference is itself immutable and cannot be changed, the object that it points to may be mutable.
Var variable can change its value, but the type is fixed.

2.1.4 String templates
String templates: concatenation of variable and string literal. 
$ character: to help interpret as variable refence. 
${} charater: help to interpret expression.

fun main(args: Array<String>) {
	println("Hello, ${if (args.size > 0) args[0] else "someone"}!")
}

2.2 Classes and properties
Class: the keyword to declare a class, which is the abstraction of a group function or value. Like function, it can take parameter. 
In Kotlin the public is the default visibility.

2.2.1 Properties
Properties: In koklin, properties are the variable encapsulate in the class, and can only be declear by val and var. The property can be access directly without invole getter and setter.
object.properties: can be access without write getter, setter, and, constructor, but you are welcome to implement a custom version getter, setter, and, constructor.

if: if expression can be set in form if (condition) truevalue else falsevalue and return specify value.

Array<T>: the declare type, T can be any type.

+ character: concatenation of string.

fun main: the function run first.

2.2.3 kotlin source code layout: directories and packages
package: to include all declarations classes, functions, and properties in the file.

import: to include library in particular package.

* character: After the package name, it will make visible to all the functions in the package.

2.3 enums and when
enum classes: define some val in the parameter, and then define the constant can add value in the form of parameter has.
enum class Color(val r:Int, val g: Int, val b: Int){
	RED(255,0,0), ORANGE(255,165,0),
	YEllow(255,255,0), GREEN(0,255,0), BLUE(0,0,255),
	INDIGO(75,0,130), VIOLET(238, 130, 238);   """Semicolon is required"""
}

2.3.3 when with arbitrary objects
when: A keyword like switch in Java, take in form:
fun mix(c1: Color, c2: Color) = 
	When (setOf(c1, c2)){
		setOf(RED, YELLOW) -> "ORANGE"
		setOf(YELLOW, BLUE) -> "GREEN"
		setOf(BLUE, VIOLET) -> "INDIGO"
	}

2.3.4 when without an argument
When can also take no argument as a expression, but the branch need to be boolean expression.
	When {
		(Condition) -> num_1
		(Condition) -> num_2
		else -> num_3
	}


setOf: A keyword check wheather two set contain the same elements. 
	When (setOf(c1,c2)){
		setOf(A,B) -> N
		setOf(C,D) -> M
		else -> throw Exception(Null)
	}

2.3.5 Smart casts: combining type checks and casts
is: Check the type of a variable, and later on, smart cast can help to cast value.
fun example(x: Any) {
    if (x is String) {
        println(x.length) // x is automatically cast to String.
    }
}

as: Casting type to different type.

any: the ultimate parent of every object.

2.3.6 Refactoring: replacing "if" with "when"
fun eval(e: Expr): Int = 
	when (e) {
		is Num -> e.value
		is Sum -> eval(e.right) + eval(e.left)
		else -> throw IllegalArgumentException("Unknown expression")
	}

2.3.7 Blocks as branches of "if" and "when"
fun evalwithLogging(e: Expr): Int =
	when (e) {
		is Num -> {
			println{"num: ${e.value}"}
			e.value
		}
		is Sum -> {
			val left = evalWithLogging(e.left)
			val right = evalWithLogging(e.right)
			println("sum: $left + $right")
			left + right
		}
		else -> throw illegalArgumentException("Unknow expression")
	}

throw: throw exception like Java did.

2.4 "while" and "for" loops
2.4.1 while loop
while& do-while: 
while (condition) { 
	/*...*/
} 

do{ 
	/*...*/
} while (condition)

2.4.2 ranges and progressions
range: write the .. operator between two values; then it will return the the interval.
note that in Kotlin ranges are closed interval, meaning the second value is also always apart of the range.

in: use in operator to check whether a value is in a range, or its opposite, !in.
fun isLetter(c: Char) =  c in "a".."z" || c in "A".."z"
"Kotlin" in setOf("Java","Scala") """using in check in string"""

downTo: progression that goes backward.
for (i in 100 downTo 1 step 3)

step: skip some value.

until: create half-closed ranges, which don't include the specified end point.
for (x in 0 until size)

2.4.3 Iterating over maps
for interation in other collection:
TreeMap<Char, String>()
for (c in "A".."F"){ //code }

2.4.4 Using an "in" check
for ((name, phonenumber) in contact)

2.5 Exception in Kotlin
try, catch, finally: handle exceptions, try can also be an expression to assign value.
Kotlin don't need explicitly write throws exception after the function declaration.

fun readNumber(reader: BufferedReader): Int? {
	try {
		val line = reader.readLine()
		return Integer.parseInt(line)
	}catch (e: NumberFormatException){
		return null
	}finally {
		reader.close()
	}
}







--------------------------------------------ch3---------------------------------------------
3.1 Creating collection in Kotlin

setOf, listOf, mapOf create a collection, by using standard java collection
val map = mapOf()

toString: java collection have a default toString implementation.
joinToString: 
fun <T> joinToString(
	collection: Collection<T>,
	separator: String,
	prefix: String,
	postfix: String
):String{
	val result = StringBuilder(prefix)
	for ((index, element) in collection.withIndex()){
		if(index > 0) result.append(separator)
		result.append(element)
	}
	result.append(postfix)
	return result.toString()
}

3.2.1 Named arguments
for the readable, kotlin add comment before the the name of arguments.

3.2.2 Default parameter values
joinToString(list, prefix = "# ") // middle argument omited

3.2.3 top-level functions and properties
@file:JvmName("StringFunctions") // change the name of the generated class that contains 
Kotlin top-level funcitons.

a function and property declare in outside of a class are visible in package.
const: equivalent to "public static final", the property will be stored in a static field.

3.3 Extension functions and properties
Extension function is a member of a class but is defined outside of it.

Kotlin is smooth integration with existing code. kotlin projects are built on top of Java
librarices such as JDK, the Android framework, anh other third-party frameworks.

fun String.lastChar(): Char = this.get(this.length -1)
receiver type		     reciever object

Kotlin can use any JVM language for extension function, use keyword this to call extension
function. However, extension functions don't have access to private or protected members of
the class.

3.3.1 Import and extension functions
extension fuction doesn't automatically become available across entire project and it need to
be import.

import strings.lastChar
val c = "Kotlin".lastChar()
And, * imports works
import strings.*

as: change the name on class or function when it is importing.
import strings.lastChar as last
val c = "Kotlin".last()

3.3.2 Calling extension functions from Java
Calling an extension function doesn't involve creating adapter objects or other runtime overhead.
Calling funciton form JAVA: call the static method and pass the reciever object instance.
Char c = StringUtilKt.lastChar("Java");

3.3.3 Utility functions as extensions
joinToString ( separator:String , prefix:String , postfix:String ):String{
	Val result = StringBuilder(prefix)
	for ((index, element) in this.withIndex()){
		if (index>0)
		result.append(separator)
		result.append(element)
	}
	result.append(postfix)
	return result.toString()
}

3.3.4 No overriding for extension function
Extension function aren't a part of class; they're declared externally to it. Even though you
can define extension functions with the same name and parameter types for a base class and its
subclass, the function that's called depends on the static type of the variable being declared,
not on the runtime type of the value stored in that variable.

a extension function can only be override within the class where override was defined.
Because it's static function in both Java and Kotlin.

3.3.5 Extension properties
Extension properties provide a way to extend classes with APIs that can be accessed using
the property syntax, rather than thd function syntax.

val String.lastChar: Char
	get() = get(length - 1)
The getter must always be defined, because there's no backing field and therefore no default
getter implementation and there's nowhere to store the value specified as the initializer.

StringBuilder:
var String.lastChar: Char
	get() = get(length - 1)
	set(value: Char){
		this.setCharAt(length - 1, value)
	}

3.4 Working with collections: varargs, infix calls, and library support
vararg: allows you to declare a function taking an arbitrary number of arguments.
An infix notation that lets you call some one-argument function without ceremony.
Destructuring declarations that allow you to unpack a single composite value into multiple
variables

3.4.1 Extending the Java collections API
Why we can use collections in Kotlin while using the Java library classes?
Because last, max function are declared as extension functions
fun <T> List<T>.last(): T
fun Collection<Int>.max(): Int

3.4.2 Varargs: functions that accept an arbitrary number of arguments
varargs: a feature that allows pass an arbitrary number of values to a method by packing them in
an array, and in Kotlin, it uses vararg modifier on the parameter.

fun <T> asList(vararg ts: T): List<T> {
    val result = ArrayList<T>()
    for (t in ts) // ts is an Array
        result.add(t)
    return result
}

Spread operator: *operator -> uppack the array
val a = arrayOf(1, 2, 3)
val list = asList(-1, 0, *a, 4)

3.4.3 Working with pairs: infix calls and destructuring declarations
val map = mapOf(1 to "one", 7 to "seven", 53 to "fifty-three")

infix call: the word "to" in this line isn't a built-in construct, but rather a method invocation.
1.to("one") is same as 1 to "one"

infix modifier: Infix calls can be used with regular methods and extension functions that have one
required parameter. To allow a function to be called using the infix notation, you need to
mark it with the infix modifier.

infix fun Any.to(other: Any) = Pair(this, other)

to funciton returns an instance of Pair, like
val (number, name) = 1 to "one"

fun <K, V> mapOf(vararg values: Pair<K, V>): Map<K, V>

3.5 Working with strings and regular expressions
Kotlin strings are exactly the same things as Java strings, no additional wrapper objects are created.

3.5.1 Splitting Strings
toRegex: Casting a string to regular expression
string.split(delimiter)

3.5.2 Regular expressions and triple-quoted strings
val regex = """(.+)/(.+)\(.+)""".toRegex()

3.5.3 Multiline triple-quoted strings
"""\""" triple-quoted string can aviod escaping characters.

3.6 Local functions and extensions
nested local function:

fun User.validateBeforeSave() {
	fun validate(value: String, fieldName: String){
		if (value.isEmpty()) {
			throw IllegalArgumentException(
				"Can't save user $id: empty $fieldName")
		}
	}
	validate(name, "Name")
	validate(address, "Address")
}










---------------------------------------Ch4-------------------------------------------------

4.1 Defining class hierarchies
sealed modifier: restricts the possible subclasses of a class.

4.1.1 interface in kotlin
interface: to declare an interface in Kotlin, use interface keyword instead class keyword.

override: override methods and properties from superclass or interface, but in kotlin it's
mandatory to have it.

You can also override a val property with a var property, but not vice versa. This is allowed 
because a val property essentially declares a getter method, and overriding it as a var 
additionally declares a setter method in the derived class.

default function: Kotlin has no special annotation for default keywords, and you jest provide
a method body.
interface clickable{
	fun click()
	fun showOff() = println("I'm clickable!")
}

super<Clickable>.showOff() 

interface long_fish{ fun eating()}
interface small_fish{ fun eating()}

class tiny_fish: long_fish, samll_fish{
	override fun eating(){ ... }
}

implement rule: if there is a defined function in many interfaces, and we try to run it in class, 
then the compiler error will show up, "the class function must override, because it inhertis many 
implementations of it".

super: call the parent class.

override fun eating()= super<long_fish>.eating()
// implement only one interface.

override fun eating()= {
	super<tiny_fish>.eating()
	super<long_fish>.eating()
}
// implement both interfaces.

4.1.2 Open, final, and abstract modifiers: final by default
fragile base class problem occurs when modifications of a base class can cause incorrect
behavior of subclasses because the changed code of the base class no longer matches the
assumptions in its subclasses.

Programming style: all classes and methods that aren't specifically intended to be overridden in
subclasses need to be explicityly marked as final, since the modifications of a base class can
cause incorrect behaivior of subclasses.

Java's classes and methods are open by default, Kotlin's are final by default
open modifier: allow subclasses to override. The overrides function is open by default.
final modifier: add final to close the override functions.

abstract modifier: this class can't be instantiated, must be override insubclasses. Abstract
members are always open.
abstract class name{
	abstract fun namename()
	open fun namenamely(){}
	fun namenamename()
}

final Can't overridden
open Can be overridden
abstract Must be overridden  can be used only in abstract classes

4.1.3 Visibility modifiers: public by default
public: this is the default visibility in Kotlin; package-private is the defaul visibility in
Java. Kotlin use package only for organizing code in namespaces.

internal: visible inside a module, which is a set of Kotlin files compiled together.
In Java, the encapsulation can be accesse by external code define classes in the same packages.

protected: only visible in the class and its subclasses.

public(default)	visible everywhere
internal	visible in a module
protected	visible in subclasses
private		visible in a class

4.1.4 inner and nested classes: nested by default 
Kotlin nested classes don't have access to the outer class instance, unless specifically reqested.

Use this@Outer to access the Outer class from the Inner class:

class Outer{
	inner class Inner {
		fun getOuterReference(): Outer = this@Outer
	}
}

inner class: stores a reference to outer class.
nested class: don't store a reference, this is the default.

4.1.5 Sealed class: restricting hierarchies
Sealed modifier: restricted the possibility of creating subclasses. All the direct subclass
must nested in the superclass.

Sealed modifier implies that the class is open.

4.2 Declaring class with nontrivial constructors or properties
In both java and kotlin, a class can declare one or more constructors.

4.2.1 Initializing classes: primary constructor and initializer blocks
Primary constructor: parameters surrounded by curly braces.
class User constructor{ _nickname: String}{
	val nickname: String
	init{
		nickname = _nickname
	}
}
constructor: declaration of a primary or secondary constructor.
init: introduces an initializer block, which contains initialization code.
Primary constructor has a constrained syntax, it can't contain the initializaiton code.

Alternally:
this.nickname = nickname
class user(_nickname: String){ val nickname = _nickname}
class user(val nickname: String val isSubscribed: Boolean = true)

To create an instance of a class, we call the constructor directly, without new keywords.

If the class has a superclass, the primary constructor also needs to initialize the  superclass.
open class User(val nickname:String){...}
class TwitterUser(nickname:String){...}

interfaces don't have constructors, so never need to put parentheses after its name in the supertype list.

4.2.2 Secondary constructors: initializing the superclass in different ways.
default parameter values cover most multiple constructors case.

Multiple constructors: cinitialize the class in different ways. 
primary constructor: after class covered by parentheses, and need initl to do assign.
secondary constructor: start by keywork constructor, can use super keyword to invoke parenter constructor.

this: can be use for calling another constructor from one class.

class MyButton: View {
	constructor(ctx: Context): this(ctx, MY_STYLE) {
		//...
	}
	constructor(ctx: Context, attr: AttributeSet): super(ctx, attr){
		//...
	}
}

4.2.3 Implementing properties declared in interfaces
Interface can contain abstract property declarations.
So have to override and can be set for custom getter and property initializer.

4.2.4 Accessing a backing field from a getter or setter
custom getter & setter: additional logical after variable decleared. 
Using field to refer to itself, so we don't fall into a dead loop.

class User(val name: String) {
	var address: String = "unspecified"
		set(value: String) {
			println("""
				Address was changed for $name:
				"$field" -> "$value".""".trimIndent())
			field = value
		}
}

use user.property = "String" to invoke a setter under the hood.(mutable property only)
use user.property to invoke a getter.

4.2.5 Changing accessor visibility
Visibility modifier can be putting before the get and set.
Put private set or get to make it only visible in class.

4.3 Compiler-generated methods: data classes and class delegation
Kotlin compiler can perform mechanical code generation, without cluttering the source code files.

4.3.1 Universal object methods
override fun toString() = "$parameter, $parameter"

In Kotlin, == checks whether the objects are equal, not the references.
== is the default way to compare two objects: it compares their values by calling equals under
the hood. Thus, if equals is overridden in the class, you can safely compare its instances
using ==. For reference comparison, you can use the === operator, which works exactly the same
as == in Java.

Any is the analogue of java.lang.Object: a superclass of all classes in Kotlin. The nullable type
Any? means the object can be null.

HashSet: at first compare hash codes, and only if codes are equal, thel the actual values compared.
override fun hashCode(): Int = name.hashCode() * 31 + postalCode

4.3.2 Data classes: autogenerated implementations of universal methods
Don't have to generate all these methods in Kotlin. If you add the modifier data to your class, all
the necessary methods are automatically generated.

equal() and hashCode methods take into account all the properties declared in the PRIMARY constructor.

Strongly recommended to use the read-only properties. This is required if use a instances as keys in
a HashMap or a similar container, because otherwise the container could get into an invalid state if
the object used as a key was modified after it was added to the container.

copy: copy an object.
class Client(val name: String, val postalCode: Int) {
	fun copy(name: String = this.name, 
	postalCode: Int = this.postalCode) = Client(name, postalCode)
}

Immutable objects are also good at multithreaded code: once an object has been created, it remains in 
its original state, and you don't need to worry about other threads modifying the object while your
code is working with it.

In data classes, complier generates a copy method that allows to copy the instances. The copy has a
separate lifecycle and can't affect the places in the code that refer to the original instance.

4.3.3 Class delegation: using the "by" keyword
common problem in design of large object-oriented systems is fragility caused by implementation
inheritance, because it build up level by level. 

final as default ensures that only those classes that are designed for extensibility can be inherited
from. 

Decorator pattern: need to add behavior to another class, when it's not designed for extension.
Therefor create a new class and then implementing the same interface as the original class.
Finally, you can override the default function and costum the behavior.

by: delegating the implementation of the interface to another object. The compiler will generate similar
So there is not need for override every function in the collection.

class CountingSet<T>( val innerSet: MutableCollection<T> = HashSet<T>() 
) :MutableCollection<T> by innerSet {
	var Countings = 0
	override fun add(element: T): Boolean{
		Countings++
		return innerSet.add(element)
	}
	override fun addAll(c: Collection<T>): Boolean{
		Countings++
		return innerSet.addAll(c)
	}
}

4.4 Declaring a class and creating an instance, combined, with the object keyword
object: the keyword defines a class and creates only one object. Singletons support.

4.4.1 Object declarations: singletons made easy
Singleton pattern: you define a class with a private constructor and a static field holding
the only existing instance of the class.

object payroll {
	val allEmployees = arrayListOf<Person>()
	fun calcglateSalary() {
		for(person in allEmployees) [
			//...
		}
	}
}

The object declaration combine a class declaration and a declaration of a single instane of
that class.

Object declarations can also inherit from classes and interfaces.

Since there is only one variable, an object declaration can call all methods and all properties.

Payroll.allEmployees.add(Person(...))
Payroll.calculateSalary()

4.4.2 Companion objects: a place for factory methods and static members
Classes in Kotlin can¡¯t have static members. Kotlin relies on package-level functions and 
object declarations.

companion: the ability to access the methods and properties of that object directly through 
the name of the containing class, without specifying the name of the object explicitly.

class A {
	companion object{
		fun bar() {
			//...
		}
	}
}

4.4.3 Companion objects as regular objects

class Person(val name: String){
	companion object Loader{
		fun fromJSON(jsonText: String): Person = //...
	}
}

>>> person = Person.Loader.fromJSON("{name: 'Dmitry'}")
>>> person.name
Dmitry

4.4.4 Object expressions: anonymous inner classes rephrased
The object keyword can be used for declaring anonymous objects.

Kotlin anonymous object can be implement multiple interfaces or no interfaces.
window.addMouseListener(
	object : MousAdepter() {
		override fun mouseClicked(e: MousdEvent){
			//...
		}
		override fun mousdEntered(e: MouseEvent){
			//...
		}
	}
)

The code in anonymous object can be access the variables in the function where it was created.
And it's not a final variable.

fun countClicks(window: Window){
	var clickCount = 0 
	windows.addMouseListener(object: MouseAdapter(){
		override ful mouseClicked(e: MouseEvent){
			clickCount++
		}
	})
}



------------------------------------------ch5-----------------------------------------------

Lambdas are essentially small chuncks of code that can be passed to other functions.

5.1 Lambda expressions and memeber references
5.5.1 Introduction to lambdas: blocks of code as method parameters

Try treat fnuctions as values.
Lambda is good subsitute for verbositily anonymous inner clas.s
button.setOnClickListener{ /* actions */}

5.1.2 Lambdas eand collections

Prinple of Good programming style is to avoid any duplication in code

people.maxBy { it.age }
// Finds the maximum by comparing the ages.
people.maxBy(Person::age)
// replaced by a member reference

5.1.3 Syntax for lambda expressions
Lambda can store a value independently.
{x:Int, y:Int -> x + y}
  parameters      body

can be treat as normal function.
val sum = { x: Int, y: Int -> x +y }

run { println(42) } // use library function run to executes the lambda

people.maxBy({ p:Person -> p.age})
//pass it as an argument to the function and it takes one argument of type Person and returns
its age.
This code is verbose.
First, there's too much punctuation, which hurts readability.
Second, the type can be inferred from the context and therefore omitted.
Last, you don't need to assign a name to lambda argument in this case.

When you have several arguments, you can emphasize that the lambda is an argument by leaving 
it inside the parentheses, or you can put it outside.

From here:
val names = people.joinToString(separator = " ", transform = { p: Person -> p.name })
To:
people.joinToString(" ") { p: Person -> p.name }

From here:
people.maxBy { p: Person -> p.age }
To:
people.maxBy { p -> p.age }
// Argument type inferred

Lambda default argument name: it
people.maxBy{ it.age }
Don't abuse it, in nested lambdas it's hard to understand which value the it refers to.

If a lambda is stored in a variable, there's no context from which to infer the argument types,
so have to specify it:

val getAge = { p:Person -> p.age }
people.maxBy(getAge)

5.1.4 Accessing variables in scope

By default, the lifetime of a local variable is constrained by function.
But lambda can stored and executed the variable later.

When lambda capture a final variable, its value is stored together with the lambda code that use it.
For non-final variable, the value is enclosed in a spceial wrapper that lets to change, and 
the reference to the wrapper is stordd together with the lambda.

5.1.5 Member references
Member references: val getAge = Person::age
                              class      member
It provides a short syntax for creating a function value that calls exactly one method or 
accesses a property. 

people.maxBy(Person::age)
A member reference has the same type as a lambda that calls that function.

It can be declared at the top level
fun salute() = println("Salute!")
>>> run(::salute)
Salute!

It can take several parameters
val action = { person: Person, message: String -> sendEmail(person, message) }
val nextAction = ::sendEmail

It can store the action of creating an instance of a class using a constructor reference.
data class Person(val name: String, val age: Int)
>>> val createPerson = ::Person
>>> val p = createPerson("Alice", 29)
>>> println(P)
Person("Alice", 29)

fun Person.isAdult() = age >= 21
val predicate = Person::isAdult

bound-method references, which allow you to use the method-reference syntax to capture a 
reference to the method on a specific object instance.

5.2 Functional APIs for collections

5.2.1 Essentials: filter and map

The filter function transforms a collection and filters out elements that don’t satisfy the 
given predicate.

>>> val list = listOf(1, 2, 3, 4)
>>> list.filter { it % 2 == 0 }
[2, 4]

The filter function can remove unwanted elements from a collection, but it doesn’t change 
the elements.
The map function will change the each element in the collection to new collection.

>>> val list = listOf(1, 2, 3, 4)
>>> list.map { it * it }
[1, 4, 9, 16]

>>> val people = listOf(Person("Alice", 29), Person("Bob", 31))
>>> people.map { it.name }
[Alice, Bob]

people.map(Person::name)

Use as a chin calls
>>> people.filter { it.age > 30 }.map(Person::name)
[Bob]

Simple-looking code using lambda
expressions can sometimes obscure the complexity of the underlying operations

It's easy to repeat calculation when multiple lambdas involve.

filterKeys and mapKeys are used for the key of map, 
filterValues and mapValues are used for the value of map.

5.2.2 all, any, count, and find: applying a predicate to a collection

all and any function: to check wheter all elements in a collection match a certain condition.
count function checks how many elements satisfy the predicate.
find function returns the first matching element.

val canBeClub27 = { p: Person -> p.age <= 27 }
>>> println(people.any(canBeInClub27))
true

!all can be replaced with any with a negated condition.
>>> val list = listOf(1, 2, 3)
>>> println(!list.all { it == 3 })
true
>>> println(list.any { it != 3 })
true

>>> println(people.find(canBeInClub27))
find returns the first matching element or return null if nothing satisfies the predicate.

5.2.3 groupBy: converting a list to a map of groups

groupBy function: divide all elements into different groups according to some quality.
Each group is stored in a list, so the result type is Map<Int, List<T>>
using funciton mapKeys, mapValues for further modifications.

>>> val list = listOf("a", "ab", "b")
>>> println(list.groupBy(String::first))
{a=[a, ab], b=[b]}

first isn't a member of String class, it's an extension. We can access it as a member reference.

5.2.4 flatMap and flatten: processing elements in nested collections

The flatMap function does two things: 
at first it transforms each element to a collection according to the argument function, 
and then it combines (or flattens) several lists into one.

To convert a collection of collections of elements into one use flatten function.
ListOfLists.flatten()

5.3 Lazy collection operations: sequences
The operation in map and filter creates intermediate collections eagerly, meaning the
intermediate result of each step is stored in a temporary list.

Sequences give an way to perform computations that avoids the creation of intermediate temporary 
objects.

people.map(Person::name).filter { it.startsWith("A") }

people.asSequence()
.map(Person::name)
.filter { it.startsWith("A") }
.toList()

By default fliter and map return a list, which in the case above, there need to create two lists.
Use sequences to make this chain calls more efficient, because it provides only iterator method. 

You can convert any collection to a sequence by calling the extension method
asSequence. You call toList for backward conversion.

5.3.1 Executing sequence operations: intermediate and terminal operations

An intermediate operation returns another sequence, which knows how to transform the elements
of the original sequence. A terminal operation returns a result, which may be any other
collection.

sequence.map{...}.filter{...}.toList()
    intermediate operations   terminal operation

naive approach: Eager evaluation runs each operation on the entire collection.
sequence approach: lazy evaluation processes elements one by one.

Applying filter first helps to reduce the total number of transformations. 

5.3.2 Creating sequences

generateSequence() function: calculates the next element in a sequence given the previous one.

Postponed computation: The actual numbers in those sequences won’t be evaluated until you 
call the terminal operation.

>>> val naturalNumbers = generateSequence(0) { it + 1 }
>>> val numbersTo100 = naturalNumbers.takeWhile { it <= 100 }


located in a hidden directory by generating a sequence of its parent directories and
checking this quality on each of the directories:

fun File.isInsideHiddenDirectory() = generateSequence(this) { it.parentFile }
							    .any { it.isHidden }
>>> val file = File("/Users/svtk/.HiddenDir/a.txt")

Note that using sequences allows you to stop traversing the parents as soon as you find
the required directory.












------------------------------------------ch6-----------------------------------------------

6.1 Nullability
kotlin convert such NullPointerException error from runtime errors into compile-time errors.

6.1.1 Nullable types
kotlin support nullable types.
fun strLen(s: String) = s.length
If the parameter is declared as type String, and in Kotlin this means it must always contain
a string instance. No null will be accepted.

fun strLenSafe(s: String?) = ...
type? = type or null

A type without a question mark denotes that variables of this type can't store null references.

>>> fun strLenSafe(s: String?) = s.length()
ERROR: only safe (?.) or non-null asserted (!!.) calls are allowed
on a nullable receiver of type kotlin.String?

>>> val x: String? = null
>>> var y: String = x
ERROR: Type mismatch: inferred type is String? but String was expected

>>> strLen(x)
ERROR: Type mismatch: inferred type is String? but String was expected

the variable of nullable type has to be consist.

has to check and replace the null to other in order to be consist 

6.1.2 The meaning of types
In java, string instance can be null value or string, which need type check for most of times.
People skip those checks because they know from the general flow of data in the program
that a value can't be null at a cerntain point. Sometimes they're wrong, and then programs 
crashed.

6.1.3 Safe call operator: ?.

s?.toUpperCase() is equivalent to
if (s != null) s.toUpperCase() else null.

fun managerName(employee: Employee): String? = employee.manager?.name

6.1.4 Elvis operator: ?:
fun foo(s: String?) {
	val t: String = s ?: ""
}

fun Person.countryName() = company?.address?.country ?: "Unknown"

6.1.5 Safe casts: as?
as? operator tries to cast a value to the specified type and returns null if the
value doesn¡¯t have the proper type.

val otherPerson = o as? Person ?: return false
Checks the type and returns false if no match

6.1.6 Not-null assertions: !!
fun ignoreNulls(s: String?) {
	val sNotNull: String = s!!
	println(sNotNull.length)
}
>>> ignoreNulls(null)
	Exception in thread "main" kotlin.KotlinNullPointerException
	at <...>.ignoreNulls(07_NotnullAssertions.kt:2)

When the variable is null, then !! will throw Null exception.

avoid using multiple 1! assertions on the same line:
person.company!!.address!!.country

6.1.17 The let function
let function deal with a nullable argument that should be passed to a function that expects
a non-null parameter.

let funtiotn will make a safe call.

email?.let { email -> sendEmailTo(email) }
if email != null then sendEmailTo(email)
if email == null then do nothing

6.1.8 Late-initialized properties
Many frameworks initialize objects in dedicated methods called after the object instance has
been created. But Kotlin requires to initiallize all properties in the constructor if a
property has a non-null type. 

class Mytest {
	private lateinit var myService: MyService
	@Before fun setUp(){
		myService = MyService()
	}

	@Test fun testAction(){
		Assert.assertEquals("foo", myService.performAction()))
	}
}

Note that a late-initialized property is always a var.

To ensure compatibility with a broad range of Java frameworks, Kotlin generates a field with
the same visibility as the lateinit property. If the property is declared as public , the 
field will be public as well.

6.1.9 Extensions on nullable types
Extension functions can receive a null type and deal it in the function, but regular function
can't, since it dispatched through the object instance and therefore can never be preformed
when the instance is null.

Extensions of nullable types can be accessed without a safe call.

fun String?.isNullOrBlank(): Boolean = this == null || this.isBlank()
When delcare an extension function for a nullable type(ending with?), that means a nullable
function can be called, and this in a function body can be null.

let function can receive a nullable type but let doesn't check the value for null.
So to check the arguments for non-null with let, we have to use the safe-call opertor ?.

by default, an extension is a non-null type. We can safely change it later.

6.1.10 Nullability of type parameters
All parameters of functions and classes in Kotlin are nullable.

fun <T> printHashCode(t: T){ 
	println(t?.hashCode())
}
>>> printHashCode(null)
null

To mark the type parameter non-null, we need specify a non-null upper bound. 

fun <T: Any> printHashCode(t: T){
	println(t.hashCode())
}
>>> printHashCode(null)
Error: Type parameter bound for 'T' is not satisfied
>>> printHashCode(42)
42

6.1.11 Nullability and Java
null`s in the Kotlin world. But Kotlin prides itself on its Java interoperability, and you
know that Java doesn¡¯t support nullability in its type system. So what happens when you 
combine Kotlin and Java? Do you lose all safety, or do you have to check every value for `null ?

@Nullable + Type = Type?
@NotNull + Type = Type
      Java         Kotlin

Be careful while working with Java APIs. Most of the libraries aren¡¯t annotated, so
you may interpret all the types as non- null , but that can lead to errors.

6.2 Primitive and other basic types
6.2.1 Primitive types: Int, Boolean, and more
primitive type: (Int) holds its value directly.
reference type: (String) holds a reference to the memory location containing the object.

primitive type can  be stored and passed around efficently, but can't call methods on such
values or store them in collections. Java provides special wrapper types like java.lang.Integer
that encapsulate primitive types in an object.

In kotlin, primitive and reference types are the same and at runtime, the number types are
represented in the most efficient way possible.

In most cases - for variables, properties, parameter and return types - Kotlin¡¯s Int
type is compiled to the Java primitive type int . The only case where this is not possible
is generic classes such as collections. A primitive type used as a type argument of a
generic class will be compiled to the corresponding Java wrapper type.
6.1.11 Nullability and Java
null`s in the Kotlin world. But Kotlin prides itself on its Java interoperability, and you
know that Java doesn¡¯t support nullability in its type system. So what happens when you 
combine Kotlin and Java? Do you lose all safety, or do you have to check every value for `null ?

@Nullable + Type = Type?
@NotNull + Type = Type
      Java         Kotlin

Be careful while working with Java APIs. Most of the libraries aren¡¯t annotated, so
you may interpret all the types as non- null , but that can lead to errors.

6.2 Primitive and other basic types
6.2.1 Primitive types: Int, Boolean, and more
primitive type: (Int) holds its value directly.
reference type: (String) holds a reference to the memory location containing the object.

primitive type can  be stored and passed around efficently, but can't call methods on such
values or store them in collections. Java provides special wrapper types like java.lang.Integer
that encapsulate primitive types in an object.

In kotlin, primitive and reference types are the same and at runtime, the number types are
represented in the most efficient way possible.

In most cases - for variables, properties, parameter and return types - Kotlin¡¯s Int
type is compiled to the Java primitive type int . The only case where this is not possible
is generic classes such as collections. A primitive type used as a type argument of a
generic class will be compiled to the corresponding Java wrapper type.

6.2.2 Nullable primitive types: Int?, Boolean?, and more
Nullable types in Kotlin can¡¯t be represented by Java primitive types, because null can
only be stored in a variable of a Java reference type. That means whenever you use a
nullable version of a primitive type in Kotlin, it¡¯s compiled to the corresponding wrapper
type.

You can¡¯t just compare two values of type Int? , because one of them may be null . Instead, 
you have to check that both values aren¡¯t null . After that, the compiler allows you to 
work with them normally.

6.2.3 Number conversions
val i = 1
val l: Long = i
Error: type mismatch

Conversion functions are defined for every primitive type: toByte(), toShort(), toChar()
The functions support converting in both directions: extending a smaller type to a larger one
like Int.toLong() and truncating a larger type to a smaller one, like Long.toInt().

The equals method for two boxed values checks the box type, not just the value stored in it.

In java, new Integer(42).equals(new Long(42)) will returns false.
In kotlin:
val x=1
x.toLong() in listOf(1L, 2L, 3L) //return true

Primitive type literals
Kotlin supports the following ways to write number literals in source code, in
addition to simple decimal numbers:
Literals of type Long use the L suffix: 123L .
Literals of type Double use the standard representation of floating-point
numbers: 0.12 , 2.0 , 1.2e10 , 1.2e-10 .
Literals of type Float use the 'f' or F suffix: 123.4f , .456F , 1e3f .
Hexadecimal literals use the 0x or 0X prefix (such as 0xCAFEBABE or 0xbcdL ).
Binary literals use the 0b or 0B prefix (such as 0b000000101 ).

when you¡¯re writing a number literal, you usually don¡¯t need to use conversion functions.

6.2.4 Any and Any?: the root types
any is the supertype of all non-nullable types in Kotlin.

6.2.5 The Unit type: Kotlin¡¯s "void"
Unit is the void type in Kotlin. 
fun f(): Unit{} // Unit is usually omitted

Unit is a full-fledged type, and unlike void, it can be used as a type argument.

interface Processor<T>{ 
	fun process(): T
}
class NoResultProcessor : Processor<Unit>{ 
	override fun process() {
		// something
	}	// no return need here
}

6.2.6 The Nothing type: "This function never returns"
When analyzing code that calls such a function, it¡¯s useful to know that the function will 
never terminate normally. To express that, Kotlin uses a special return type called Nothing.

fun fail(message: String): Nothing{
	throw IllegalStateException(message)
}

The Nothing type doesn¡¯t have any values, so it only makes sense to use it as a function 
return type or as a type argument.

6.3 Collections and arrays
6.3.1 Nullability and collections
fun readNumbers(reader: BufferedReader): List<Int?> {
	val result = ArrayList<Int?>()
	for (line in reader.lineSequence()){ 
		try {
			val number = line.toInt()
			result.add(number)
		}
		catch(e: NumberFormatException) {
			result.add(null)}
		}
	}
	return result
}

6.3.2 Read-only and mutable collections
A key thing to keep in mind when working with collection interfaces is that read-only
collections aren¡¯t necessarily immutable. If you¡¯re working with a variable that has a
read-only interface type, this can be just one of the many references to the same
collection. Other references can have a mutable interface type.

6.3.3 Kotlin collections and Java
Collection Read-only    Mutable
List 	   listOf() 	arrayListOf()
Set 	   setOf() 	hashSetOf() , linkedSetOf() , sortedSetOf()
Map 	   mapOf() 	hashMapOf() , linkedMapOf() , sortedMapOf()

This has important consequences with regard to mutability of collections. Because
Java doesn¡¯t distinguish between read-only and mutable collections, Java code can
modify the collection even if it¡¯s declared as a read-only Collection on the Kotlin side.
The Kotlin compiler can¡¯t fully analyze what¡¯s being done to the collection in the Java
code, and therefore there¡¯s no way for Kotlin to reject a call passing a read-only
Collection to Java code that modifies it.

Therefore, if you¡¯re writing a Kotlin function that takes a collection and passes it to
Java, it¡¯s your responsibility to use the correct type for the parameter.

6.3.4 Collections as platform types
platform types in Kotlin 

When overriding or implementing a Java method the collection type can be either nullable 
or non-null Here. You need to decide which Kotlin type you¡¯re going to use to represent a 
Java type coming from the method you¡¯re overriding or implementing.

think about:
Is the collection nullable?
Are the elements in the collection nullable?
Will your method modify the collection?

6.3.5 Arrays of objects and primitive types

The arrayOf() function creates an array containing the elements specified as arguments
to this function.

The arrayOfNulls() function creates an array of a given size containing null elements.

The Array() constructor takes the size of the array and a lambda function, and initializes
each array element by calling the lambda. This is how you can initialize an array with a
non-null element type without passing each element explicitly.

toIntArray(): convert an array or a collection that holding boxed values of a primitive type
to an array of that primitive type using the corresponding conversion function.

forEachIndexed(): 
fun main(args: Array<String>){
	args.forEachIndexed { index, element
	->
	println("Argument $index is: $element")
	}
}

